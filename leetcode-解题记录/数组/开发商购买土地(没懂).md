# 开发商购买土地(**)

[题目链接](https://gitee.com/link?target=https%3A%2F%2Fkamacoder.com%2Fproblempage.php%3Fpid%3D1044)

【题目描述】

在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。

现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。

然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。

为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。

注意：区块不可再分。

【输入描述】

第一行输入两个正整数，代表 n 和 m。

接下来的 n 行，每行输出 m 个正整数。

输出描述

请输出一个整数，代表两个子区域内土地总价值之间的最小差距。

【输入示例】

3 3 1 2 3 2 1 3 1 2 3

【输出示例】

0

【提示信息】

如果将区域按照如下方式划分：

1 2 | 3 2 1 | 3 1 2 | 3

两个子区域内土地总价值之间的最小差距可以达到 0。

【数据范围】：

- 1 <= n, m <= 100；
- n 和 m 不同时为 1。

## 思路

```c
#include <stdlib.h>
#include <stdio.h>

int main()
{
    int n = 0, m = 0, ret_ver = 0, ret_hor = 0;

    // 读取行和列的值
    scanf("%d%d", &n, &m);
    // 动态分配数组a(横)和b(纵)的空间
    int *a = (int *)malloc(sizeof(int) * n);
    int *b = (int *)malloc(sizeof(int) * m);

    // 初始化数组a和b
    for (int i = 0; i < n; i++)
    {
        a[i] = 0;
    }
    for (int i = 0; i < m; i++)
    {
        b[i] = 0;
    }

    // 读取区块权值并计算每行和每列的总权值
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            int tmp;
            scanf("%d", &tmp);
            a[i] += tmp;
            b[j] += tmp;
        }
    }

    // 计算每列以及每行的前缀和
    for (int i = 1; i < n; i++)
    {
        a[i] += a[i - 1];
    }
    for (int i = 1; i < m; i++)
    {
        b[i] += b[i - 1];
    }

    // 初始化ret_ver和ret_hor为最大可能值
    ret_hor = a[n - 1];
    ret_ver = b[m - 1];

    // 计算按行划分的最小差异
    int ret2 = 0;
    while (ret2 < n)
    {
        ret_hor = (ret_hor > abs(a[n - 1] - 2 * a[ret2])) ? abs(a[n - 1] - 2 * a[ret2]) : ret_hor;
        // 原理同列，但更高级
        ret2++;
    }
    // 计算按列划分的最小差异
    int ret1 = 0;
    while (ret1 < m)
    {
        if (ret_ver > abs(b[m - 1] - 2 * b[ret1]))
        {
            ret_ver = abs(b[m - 1] - 2 * b[ret1]);
        }
        ret1++;
    }

    // 输出最小差异
    printf("%d\n", (ret_ver <= ret_hor) ? ret_ver : ret_hor);

    // 释放分配的内存
    free(a);
    free(b);
    return 0;
}

```

