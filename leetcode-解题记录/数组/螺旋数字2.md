# 螺旋矩阵II

[力扣题目链接](https://gitee.com/link?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fspiral-matrix-ii%2F)

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg)

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

**示例 2：**

```
输入：n = 1
输出：[[1]]
```

**提示：**

- `1 <= n <= 20`

思路1:int l, r,t,b定义为墙,按照顺时针方向填写,撞到墙就拐弯

```c
int** generateMatrix(int n, int* returnSize, int** returnColumnSizes) {
   //初始化返回的结果数组的大小
    *returnSize = n;
    *returnColumnSizes = (int*)malloc(sizeof(int) * n);
    //初始化返回结果数组ans
    int** ans = (int**)malloc(sizeof(int*) * n);
    for( int i = 0; i < n; i++) {
        ans[i] = (int*)malloc(sizeof(int) * n);
        (*returnColumnSizes)[i] = n;
    }
     int l = 0, r = n - 1, t = 0, b = n - 1;
     int num = 1, tar = n * n;
        while(num <= tar){
            for(int i = l; i <= r; i++) ans[t][i] = num++; // left to right.
            t++;
            for(int i = t; i <= b; i++) ans[i][r] = num++; // top to bottom.
            r--;
            for(int i = r; i >= l; i--) ans[b][i] = num++; // right to left.
            b--;
            for(int i = b; i >= t; i--) ans[i][l] = num++; // bottom to top.
            l++;
        }
     return ans;
}
```



思路2:

按照左闭右开的原则，来画一圈，大家看一下：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20220922102236.png)

这里每一种颜色，代表一条边，我们遍历的长度，可以看出每一个拐角处的处理规则，拐角处让给新的一条边来继续画。

这也是坚持了每条边左闭右开的原则。

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
 int** generateMatrix(int n, int* returnSize, int** returnColumnSizes) {
    //初始化返回的结果数组的大小
    *returnSize = n;
    *returnColumnSizes = (int*)malloc(sizeof(int) * n);
    //初始化返回结果数组ans
    int** ans = (int**)malloc(sizeof(int*) * n);
    int i;
    for (i = 0; i < n; i++) {
        ans[i] = (int*)malloc(sizeof(int) * n);
        (*returnColumnSizes)[i] = n;
    }
    int loop = n - 1;
    int l = 0;
    int r = 0;
    int count = 1;
    int max = n * n;
    while (count < max) {
        for (int i = loop; i > 0; i--) {
            ans[l][r++] = count++;//向右
            //printf_s("%d,%d  ", l, r);
        }
        for (int i = loop; i > 0; i--) {
            ans[l++][r] = count++;//向下
            //printf_s("%d,%d  ", l, r);
        }
        for (int i = loop; i > 0; i--) {
            ans[l][r--] = count++;//向左
            //printf_s("%d,%d  ", l, r);
        }
        for (int i = loop; i > 0; i--) {
            ans[l--][r] = count++;//向上
            //printf_s("%d,%d  ", l, r);
        }
        loop -=2 ;//每一圈loop减2
        l++;
        r++;
    }
    //若n为奇数需要单独给矩阵中间赋值
    if (n % 2)
        ans[n / 2][n / 2] = count;
    return ans;
}
```

注:

在C语言中，函数`int** generateMatrix(int n, int* returnSize, int** returnColumnSizes)`的两个参数`int* returnSize`和`int** returnColumnSizes`用于向调用者传递动态生成的二维数组的维度信息。以下是它们的详细作用：

---

### **1. `int* returnSize` 的作用**
- **功能**：返回二维数组的行数。
- **实现方式**：
  - 函数内部通过解引用指针设置值：`*returnSize = n;`。
  - 调用者传入一个整型变量的地址（如`&rows`），函数执行后该变量会被赋值为`n`。
- **示例**：
  ```c
  int rows;  // 调用者定义的变量
  generateMatrix(n, &rows, ...); // 函数内部设置 rows = n
  ```

---

### **2. `int** returnColumnSizes` 的作用**
- **功能**：返回每行的列数（数组形式）。
- **实现方式**：
  1. 函数内部分配一个长度为`n`的整型数组，存储每行的列数：
     ```c
     *returnColumnSizes = (int*)malloc(sizeof(int) * n);
     ```
  2. 每行的列数被初始化为`n`（因为生成的是`n×n`矩阵）：
     ```c
     for (i = 0; i < n; i++) {
         (*returnColumnSizes)[i] = n;
     }
     ```
- **调用者用法**：
  ```c
  int* colSizes;  // 调用者定义的指针
  generateMatrix(n, ..., &colSizes); // 函数内部分配并填充 colSizes
  // 通过 colSizes[i] 获取第i行的列数
  ```

---

### **关键注意事项**
1. **内存管理**：
   - `returnColumnSizes`指向的内存由函数内部分配（`malloc`），**调用者需手动释放**：
     ```c
     free(returnColumnSizes); // 使用完毕后释放
     ```
   - 若未释放，会导致内存泄漏。

2. **数据一致性**：
   - 对于`n×n`矩阵，每行的列数均为`n`，因此`returnColumnSizes`数组的每个元素值相同。
   - 若函数生成的是锯齿数组（各行列数不同），`returnColumnSizes`会记录实际列数。

3. **接口设计**：
   - 这种设计允许函数返回动态分配的二维数组及其维度信息，是C语言中处理动态多维数组的标准模式。
   - 调用者需通过`returnSize`和`returnColumnSizes`正确解析返回的二维数组结构。

---

### **调用示例**
```c
int main() {
    int n = 3;
    int rows;          // 接收行数
    int* colSizes;     // 接收每行的列数数组
    int** matrix = generateMatrix(n, &rows, &colSizes);

    // 打印矩阵
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < colSizes[i]; j++) {
            printf("%2d ", matrix[i][j]);
        }
        printf("\n");
    }

    // 释放内存
    for (int i = 0; i < rows; i++) free(matrix[i]);
    free(matrix);
    free(colSizes);

    return 0;
}
```

---

### **总结**
- `returnSize`：告知调用者二维数组的行数。
- `returnColumnSizes`：告知调用者每行的列数（通过动态分配的数组）。
- 这种设计模式使得C语言函数能够灵活返回动态生成的二维数组及其元数据，调用者需正确处理内存释放。

## 类似题目

- [54.螺旋矩阵](https://gitee.com/link?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fspiral-matrix%2F)
- [剑指Offer 29.顺时针打印矩阵](https://gitee.com/link?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fshun-shi-zhen-da-yin-ju-zhen-lcof%2F)