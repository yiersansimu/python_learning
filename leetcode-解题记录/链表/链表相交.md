# 面试题 02.07. 链表相交

同：160.链表相交

[力扣题目链接](https://gitee.com/link?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fintersection-of-two-linked-lists-lcci%2F)

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。

图示两个链表在节点 c1 开始相交：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221657.png)

题目数据 保证 整个链式结构中不存在环。

注意，函数返回结果后，链表必须 保持其原始结构 。

示例 1：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221723.png)

示例 2：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221749.png)

示例 3：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221812.png)![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221812.png)



思路：

1.双指针

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    typedef struct ListNode ListNode;
    int sizeA=0;
    int sizeB=0;
    ListNode* A=headA;
    ListNode* B=headB;
    while(A){
        A=A->next;
        sizeA++;
    }
    while(B){
        B=B->next;
        sizeB++;
    }//计算A与B长度
    A=headA;
    B=headB;
    while(A && B && sizeA!=sizeB){//使得A与B剩余链表长度相等
        if(sizeA>sizeB){
            sizeA--;
            A=A->next;
        }else{
            sizeB--;
            B=B->next;
        }
    }
    while(A&&B){
        if(A==B){
            return A;
        }else{
            A=A->next;
            B=B->next;
        }
    }
    return NULL;
}
```

更加优雅   [力扣题解链接](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/solutions/1190240/mian-shi-ti-0207-lian-biao-xiang-jiao-sh-b8hn)

考虑构建两个节点指针A,B分别指向两链表头节点headA,headB，做如下操作：

指针A先遍历完链表headA，再开始遍历链表headB，当走到node时，共走步数为：
a+(b−c)
指针B先遍历完链表headB，再开始遍历链表headA，当走到node时，共走步数为：
b+(a−c)
如下式所示，此时指针A,B重合，并有两种情况：

a+(b−c)=b+(a−c)
若两链表有公共尾部 (即c>0) ：指针A,B同时指向「第一个公共节点」node。
若两链表无公共尾部 (即c=0) ：指针A,B同时指向null。
因此返回A即可。

```c
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    typedef struct ListNode ListNode;
    ListNode *A = headA, *B = headB;
        while (A != B) {
            A = A != NULL ? A->next : headB;
            B = B != NULL ? B->next : headA;
        }
        return A;
}

```

2.哈希集合//未看
思路和算法

判断两个链表是否相交，可以使用哈希集合存储链表节点。

首先遍历链表headA，并将链表headA中的每个节点加入哈希集合中。然后遍历链表headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：

如果当前节点不在哈希集合中，则继续遍历下一个节点；

如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表headB中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点。

如果链表headB中的所有节点都不在哈希集合中，则两个链表不相交，返回null。

```c
struct HashTable {
    struct ListNode *key;
    UT_hash_handle hh;
};

struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    struct HashTable *hashTable = NULL;
    struct ListNode *temp = headA;
    while (temp != NULL) {
        struct HashTable *tmp;
        HASH_FIND(hh, hashTable, &temp, sizeof(struct HashTable *), tmp);
        if (tmp == NULL) {
            tmp = malloc(sizeof(struct HashTable));
            tmp->key = temp;
            HASH_ADD(hh, hashTable, key, sizeof(struct HashTable *), tmp);
        }
        temp = temp->next;
    }
    temp = headB;
    while (temp != NULL) {
        struct HashTable *tmp;
        HASH_FIND(hh, hashTable, &temp, sizeof(struct HashTable *), tmp);
        if (tmp != NULL) {
            return temp;
        }
        temp = temp->next;
    }
    return NULL;
}

```

