# 设计链表

[力扣题目链接](https://gitee.com/link?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fdesign-linked-list%2F)

题意：

在链表类中实现这些功能：

- get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
- addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
- addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
- addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
- deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

![707示例](https://code-thinking-1253855093.file.myqcloud.com/pics/20200814200558953.png)



```c
// 定义链表节点结构体
typedef struct Node {
    int val;            // 节点存储的值
    struct Node* next;   // 指向下一个节点的指针
} Node;

// 定义链表管理结构体
typedef struct {
    int size;    // 链表长度(不包含头节点)
    Node* data;  // 头节点指针(哨兵节点)
} MyLinkedList;

/* 初始化链表结构 */
MyLinkedList* myLinkedListCreate() {
    MyLinkedList* obj = (MyLinkedList*)malloc(sizeof(MyLinkedList)); // 分配链表管理结构内存
    Node* head = (Node*)malloc(sizeof(Node));    // 创建头节点(哨兵节点)
    head->next = (void*)0;                       // 初始化头节点的next为NULL
    obj->data = head;                            // 将头节点挂载到管理结构
    obj->size = 0;                               // 初始化链表长度为0
    return obj;
}

/* 获取指定索引节点的值 */
int myLinkedListGet(MyLinkedList* obj, int index) {
    // 索引有效性检查
    if (index < 0 || index >= obj->size) return -1;
    
    Node* cur = obj->data;  // 从头节点开始遍历
    // 移动到目标节点的前一个位置（因为包含头节点）
    while (index-- >= 0) {  // 循环 index+1 次（包含头节点）
        cur = cur->next;
    }
    return cur->val;  // 返回目标节点的值
}

/* 在链表头部插入节点 */
void myLinkedListAddAtHead(MyLinkedList* obj, int val) {
    Node* node = (Node*)malloc(sizeof(Node));  // 创建新节点
    node->val = val;                           // 设置节点值
    
    // 插入到头部（头节点之后）
    node->next = obj->data->next;  // 新节点指向原第一个节点
    obj->data->next = node;        // 头节点指向新节点
    obj->size++;                   // 链表长度增加
}

/* 在链表尾部追加节点 */
void myLinkedListAddAtTail(MyLinkedList* obj, int val) {
    Node* cur = obj->data;  // 从头节点开始遍历
    // 找到最后一个节点（next为NULL的节点）
    while (cur->next != ((void*)0)) {
        cur = cur->next;
    }
    
    Node* tail = (Node*)malloc(sizeof(Node));  // 创建新尾节点
    tail->val = val;                           // 设置节点值
    tail->next = (void*)0;                     // 尾节点的next置空
    cur->next = tail;                         // 原尾节点指向新节点
    obj->size++;                               // 链表长度增加
}

/* 在指定索引位置插入节点 */
void myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {
    if (index > obj->size) return;  // 索引超过链表长度时不插入
    
    Node* cur = obj->data;  // 从头节点开始遍历
    // 定位到插入位置的前驱节点
    while (index-- > 0) {   // 循环index次找到前驱节点
        cur = cur->next;
    }
    
    Node* node = (Node*)malloc(sizeof(Node));  // 创建新节点
    node->val = val;                           // 设置节点值
    node->next = cur->next;  // 新节点指向原位置节点
    cur->next = node;        // 前驱节点指向新节点
    obj->size++;             // 链表长度增加
}

/* 删除指定索引位置的节点 */
void myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) {
    if (index < 0 || index >= obj->size) return;  // 无效索引直接返回
    
    Node* cur = obj->data;  // 从头节点开始遍历
    // 定位到待删除节点的前驱节点
    while (index-- > 0) {   // 循环index次找到前驱节点
        cur = cur->next;
    }
    
    Node* temp = cur->next;    // 保存待删除节点
    cur->next = temp->next;    // 前驱节点跳过待删除节点
    free(temp);                // 释放被删除节点内存
    obj->size--;               // 链表长度减少
}

/* 释放整个链表内存 */
void myLinkedListFree(MyLinkedList* obj) {
    Node* tmp = obj->data;  // 从头节点开始释放
    while (tmp != NULL) {   // 遍历所有节点
        Node* n = tmp;      // 保存当前节点指针
        tmp = tmp->next;    // 移动到下一个节点
        free(n);            // 释放当前节点内存
    }
    free(obj);  // 释放链表管理结构内存
}
```

