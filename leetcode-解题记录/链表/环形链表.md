# 环形链表II

[力扣题目链接](https://gitee.com/link?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Flinked-list-cycle-ii%2F)

题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

**说明**：不允许修改给定的链表。

![循环链表](https://code-thinking-1253855093.file.myqcloud.com/pics/20200816110112704.png)



**思路**

1.判断有环(快慢指针)

slow走一步,fast走两步,如果有环则fast一定会与slow相遇;

2.找到环形入口(需要借助数学推导)

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png)

那么**相遇时**： 

slow指针走过的节点数为: `x + y`

fast指针走过的节点数：` x + y + n (y + z)`，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。

因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：

```c
(x + y) * 2 = x + y + n (y + z)
```

两边消掉一个（x+y）: `x + y = n (y + z)`

因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。

所以要求x ，将x单独放在左面：`x = n (y + z) - y` ,

整理公式之后为如下公式：`x = (n - 1) (y + z) + z `注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。

这就意味着，**从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点**。



```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode *detectCycle(struct ListNode *head) {
    typedef struct ListNode ListNode;
    //快慢指针
    ListNode* slow=head;
    ListNode* fast=head;
    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
        if(fast==slow){//相遇
            fast=head;
            while(fast!=slow){
                slow=slow->next;
                fast=fast->next;
            }
            return fast;
        }
    }
    return NULL;
}
```

